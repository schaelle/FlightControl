using System;
using System.IO.Ports;
using System.Text;
using System.Threading;
using Gadgeteer.Modules.GHIElectronics;
using GHI.Hardware.G400;
using Microsoft.SPOT;
using Microsoft.SPOT.Hardware;

namespace FlightControl.App
{
	public class Program
	{
		private const int I2CTimeout = 1000;

		private const byte MPU6050_RA_PWR_MGMT_1 = 0x6B;
		private const byte MPU6050_RA_PWR_MGMT_2 = 0x6C;
		private const byte MPU6050_PWR1_DEVICE_RESET_BIT = 7;
		private const byte MPU6050_PWR1_SLEEP_BIT = 6;
		private const byte MPU6050_PWR1_CLKSEL_BIT = 2;
		private const byte MPU6050_PWR1_CLKSEL_LENGTH = 3;
		private const byte MPU6050_CLOCK_PLL_ZGYRO = 0x03;
		private const byte MPU6050_RA_INT_PIN_CFG = 0x37;
		private const byte MPU9150_RA_MAG_ADDRESS = 0x0C;
		private const byte MPU9150_RA_MAG_XOUT_L = 0x03;
		private const byte MPU6050_RA_BANK_SEL = 0x6D;
		private const byte MPU6050_RA_MEM_START_ADDR = 0x6E;

		private const byte MPU6050_RA_XG_OFFS_TC = 0x00;
		private const byte MPU6050_RA_YG_OFFS_TC = 0x01;
		private const byte MPU6050_RA_ZG_OFFS_TC = 0x02;

		private const byte MPU6050_RA_XG_OFFS_USRH = 0x13;
		private const byte MPU6050_RA_YG_OFFS_USRH = 0x15;
		private const byte MPU6050_RA_ZG_OFFS_USRH = 0x17;

		private const byte MPU6050_TC_OTP_BNK_VLD_BIT = 0;
		private const byte MPU6050_DMP_MEMORY_CHUNK_SIZE = 16;
		private const byte MPU6050_RA_MEM_R_W = 0x6F;
		private const byte MPU6050_RA_INT_ENABLE = 0x38;
		private const byte MPU6050_RA_SMPLRT_DIV = 0x19;

		private const byte MPU6050_RA_CONFIG = 0x1A;
		private const byte MPU6050_CFG_DLPF_CFG_BIT = 2;
		private const byte MPU6050_CFG_DLPF_CFG_LENGTH = 3;
		private const byte MPU6050_DLPF_BW_42 = 0x03;

		private const byte MPU6050_CFG_EXT_SYNC_SET_BIT = 5;
		private const byte MPU6050_CFG_EXT_SYNC_SET_LENGTH = 3;
		private const byte MPU6050_EXT_SYNC_TEMP_OUT_L = 0x1;

		private const byte MPU6050_RA_GYRO_CONFIG = 0x1B;
		private const byte MPU6050_GCONFIG_FS_SEL_BIT = 4;
		private const byte MPU6050_GCONFIG_FS_SEL_LENGTH = 2;
		private const byte MPU6050_GYRO_FS_2000 = 0x03;

		private const byte MPU6050_RA_DMP_CFG_1 = 0x70;
		private const byte MPU6050_RA_DMP_CFG_2 = 0x71;

		private const byte MPU6050_RA_USER_CTRL = 0x6A;
		private const byte MPU6050_USERCTRL_DMP_EN_BIT = 7;
		private const byte MPU6050_USERCTRL_FIFO_RESET_BIT = 2;

		private const byte MPU6050_RA_FIFO_COUNTH = 0x72;
		private const byte MPU6050_RA_FIFO_R_W = 0x74;
		private const byte MPU6050_RA_ACCEL_CONFIG = 0x1C;

		private const byte MPU6050_RA_I2C_SLV0_ADDR = 0x25;
		private const byte MPU6050_RA_I2C_SLV0_REG = 0x26;
		private const byte MPU6050_RA_I2C_SLV0_CTRL = 0x27;

		private const byte MPU6050_RA_I2C_SLV2_ADDR = 0x2B;
		private const byte MPU6050_RA_I2C_SLV2_REG = 0x2C;
		private const byte MPU6050_RA_I2C_SLV2_CTRL = 0x2D;
		private const byte MPU6050_RA_I2C_SLV2_DO = 0x65;

		private const byte MPU6050_RA_I2C_SLV4_CTRL = 0x34;
		private const byte MPU6050_RA_I2C_MST_DELAY_CTRL = 0x67;

		private const byte MPU6050_RA_MOT_THR = 0x1F;
		private const byte MPU6050_RA_ZRMOT_THR = 0x21;
		private const byte MPU6050_RA_MOT_DUR = 0x20;
		private const byte MPU6050_RA_ZRMOT_DUR = 0x22;

		private const byte MPU6050_RA_INT_STATUS = 0x3A;

		private static readonly byte[] DmpMemory6 =
		{
			// bank 0, 256 bytes
			0xFB, 0x00, 0x00, 0x3E, 0x00, 0x0B, 0x00, 0x36, 0x00, 0x01, 0x00, 0x02, 0x00, 0x03, 0x00, 0x00,
			0x00, 0x65, 0x00, 0x54, 0xFF, 0xEF, 0x00, 0x00, 0xFA, 0x80, 0x00, 0x0B, 0x12, 0x82, 0x00, 0x01,
			0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x28, 0x00, 0x00, 0xFF, 0xFF, 0x45, 0x81, 0xFF, 0xFF, 0xFA, 0x72, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x03, 0xE8, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x7F, 0xFF, 0xFF, 0xFE, 0x80, 0x01,
			0x00, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x3E, 0x03, 0x30, 0x40, 0x00, 0x00, 0x00, 0x02, 0xCA, 0xE3, 0x09, 0x3E, 0x80, 0x00, 0x00,
			0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00,
			0x41, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x0B, 0x2A, 0x00, 0x00, 0x16, 0x55, 0x00, 0x00, 0x21, 0x82,
			0xFD, 0x87, 0x26, 0x50, 0xFD, 0x80, 0x00, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x00, 0x05, 0x80, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00,
			0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x6F, 0x00, 0x02, 0x65, 0x32, 0x00, 0x00, 0x5E, 0xC0,
			0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xFB, 0x8C, 0x6F, 0x5D, 0xFD, 0x5D, 0x08, 0xD9, 0x00, 0x7C, 0x73, 0x3B, 0x00, 0x6C, 0x12, 0xCC,
			0x32, 0x00, 0x13, 0x9D, 0x32, 0x00, 0xD0, 0xD6, 0x32, 0x00, 0x08, 0x00, 0x40, 0x00, 0x01, 0xF4,
			0xFF, 0xE6, 0x80, 0x79, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD0, 0xD6, 0x00, 0x00, 0x27, 0x10,

			// bank 1, 256 bytes
			0xFB, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00,
			0x00, 0x00, 0xFA, 0x36, 0xFF, 0xBC, 0x30, 0x8E, 0x00, 0x05, 0xFB, 0xF0, 0xFF, 0xD9, 0x5B, 0xC8,
			0xFF, 0xD0, 0x9A, 0xBE, 0x00, 0x00, 0x10, 0xA9, 0xFF, 0xF4, 0x1E, 0xB2, 0x00, 0xCE, 0xBB, 0xF7,
			0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x02, 0x00, 0x02, 0x02, 0x00, 0x00, 0x0C,
			0xFF, 0xC2, 0x80, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0xCF, 0x80, 0x00, 0x40, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x14,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x03, 0x3F, 0x68, 0xB6, 0x79, 0x35, 0x28, 0xBC, 0xC6, 0x7E, 0xD1, 0x6C,
			0x80, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB2, 0x6A, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3F, 0xF0, 0x00, 0x00, 0x00, 0x30,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x25, 0x4D, 0x00, 0x2F, 0x70, 0x6D, 0x00, 0x00, 0x05, 0xAE, 0x00, 0x0C, 0x02, 0xD0,

			// bank 2, 256 bytes
			0x00, 0x00, 0x00, 0x00, 0x00, 0x65, 0x00, 0x54, 0xFF, 0xEF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x01, 0x00, 0x00, 0x44, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x01, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x65, 0x00, 0x00, 0x00, 0x54, 0x00, 0x00, 0xFF, 0xEF, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,
			0x00, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

			// bank 3, 256 bytes
			0xD8, 0xDC, 0xBA, 0xA2, 0xF1, 0xDE, 0xB2, 0xB8, 0xB4, 0xA8, 0x81, 0x91, 0xF7, 0x4A, 0x90, 0x7F,
			0x91, 0x6A, 0xF3, 0xF9, 0xDB, 0xA8, 0xF9, 0xB0, 0xBA, 0xA0, 0x80, 0xF2, 0xCE, 0x81, 0xF3, 0xC2,
			0xF1, 0xC1, 0xF2, 0xC3, 0xF3, 0xCC, 0xA2, 0xB2, 0x80, 0xF1, 0xC6, 0xD8, 0x80, 0xBA, 0xA7, 0xDF,
			0xDF, 0xDF, 0xF2, 0xA7, 0xC3, 0xCB, 0xC5, 0xB6, 0xF0, 0x87, 0xA2, 0x94, 0x24, 0x48, 0x70, 0x3C,
			0x95, 0x40, 0x68, 0x34, 0x58, 0x9B, 0x78, 0xA2, 0xF1, 0x83, 0x92, 0x2D, 0x55, 0x7D, 0xD8, 0xB1,
			0xB4, 0xB8, 0xA1, 0xD0, 0x91, 0x80, 0xF2, 0x70, 0xF3, 0x70, 0xF2, 0x7C, 0x80, 0xA8, 0xF1, 0x01,
			0xB0, 0x98, 0x87, 0xD9, 0x43, 0xD8, 0x86, 0xC9, 0x88, 0xBA, 0xA1, 0xF2, 0x0E, 0xB8, 0x97, 0x80,
			0xF1, 0xA9, 0xDF, 0xDF, 0xDF, 0xAA, 0xDF, 0xDF, 0xDF, 0xF2, 0xAA, 0xC5, 0xCD, 0xC7, 0xA9, 0x0C,
			0xC9, 0x2C, 0x97, 0x97, 0x97, 0x97, 0xF1, 0xA9, 0x89, 0x26, 0x46, 0x66, 0xB0, 0xB4, 0xBA, 0x80,
			0xAC, 0xDE, 0xF2, 0xCA, 0xF1, 0xB2, 0x8C, 0x02, 0xA9, 0xB6, 0x98, 0x00, 0x89, 0x0E, 0x16, 0x1E,
			0xB8, 0xA9, 0xB4, 0x99, 0x2C, 0x54, 0x7C, 0xB0, 0x8A, 0xA8, 0x96, 0x36, 0x56, 0x76, 0xF1, 0xB9,
			0xAF, 0xB4, 0xB0, 0x83, 0xC0, 0xB8, 0xA8, 0x97, 0x11, 0xB1, 0x8F, 0x98, 0xB9, 0xAF, 0xF0, 0x24,
			0x08, 0x44, 0x10, 0x64, 0x18, 0xF1, 0xA3, 0x29, 0x55, 0x7D, 0xAF, 0x83, 0xB5, 0x93, 0xAF, 0xF0,
			0x00, 0x28, 0x50, 0xF1, 0xA3, 0x86, 0x9F, 0x61, 0xA6, 0xDA, 0xDE, 0xDF, 0xD9, 0xFA, 0xA3, 0x86,
			0x96, 0xDB, 0x31, 0xA6, 0xD9, 0xF8, 0xDF, 0xBA, 0xA6, 0x8F, 0xC2, 0xC5, 0xC7, 0xB2, 0x8C, 0xC1,
			0xB8, 0xA2, 0xDF, 0xDF, 0xDF, 0xA3, 0xDF, 0xDF, 0xDF, 0xD8, 0xD8, 0xF1, 0xB8, 0xA8, 0xB2, 0x86,

			// bank 4, 256 bytes
			0xB4, 0x98, 0x0D, 0x35, 0x5D, 0xB8, 0xAA, 0x98, 0xB0, 0x87, 0x2D, 0x35, 0x3D, 0xB2, 0xB6, 0xBA,
			0xAF, 0x8C, 0x96, 0x19, 0x8F, 0x9F, 0xA7, 0x0E, 0x16, 0x1E, 0xB4, 0x9A, 0xB8, 0xAA, 0x87, 0x2C,
			0x54, 0x7C, 0xB9, 0xA3, 0xDE, 0xDF, 0xDF, 0xA3, 0xB1, 0x80, 0xF2, 0xC4, 0xCD, 0xC9, 0xF1, 0xB8,
			0xA9, 0xB4, 0x99, 0x83, 0x0D, 0x35, 0x5D, 0x89, 0xB9, 0xA3, 0x2D, 0x55, 0x7D, 0xB5, 0x93, 0xA3,
			0x0E, 0x16, 0x1E, 0xA9, 0x2C, 0x54, 0x7C, 0xB8, 0xB4, 0xB0, 0xF1, 0x97, 0x83, 0xA8, 0x11, 0x84,
			0xA5, 0x09, 0x98, 0xA3, 0x83, 0xF0, 0xDA, 0x24, 0x08, 0x44, 0x10, 0x64, 0x18, 0xD8, 0xF1, 0xA5,
			0x29, 0x55, 0x7D, 0xA5, 0x85, 0x95, 0x02, 0x1A, 0x2E, 0x3A, 0x56, 0x5A, 0x40, 0x48, 0xF9, 0xF3,
			0xA3, 0xD9, 0xF8, 0xF0, 0x98, 0x83, 0x24, 0x08, 0x44, 0x10, 0x64, 0x18, 0x97, 0x82, 0xA8, 0xF1,
			0x11, 0xF0, 0x98, 0xA2, 0x24, 0x08, 0x44, 0x10, 0x64, 0x18, 0xDA, 0xF3, 0xDE, 0xD8, 0x83, 0xA5,
			0x94, 0x01, 0xD9, 0xA3, 0x02, 0xF1, 0xA2, 0xC3, 0xC5, 0xC7, 0xD8, 0xF1, 0x84, 0x92, 0xA2, 0x4D,
			0xDA, 0x2A, 0xD8, 0x48, 0x69, 0xD9, 0x2A, 0xD8, 0x68, 0x55, 0xDA, 0x32, 0xD8, 0x50, 0x71, 0xD9,
			0x32, 0xD8, 0x70, 0x5D, 0xDA, 0x3A, 0xD8, 0x58, 0x79, 0xD9, 0x3A, 0xD8, 0x78, 0x93, 0xA3, 0x4D,
			0xDA, 0x2A, 0xD8, 0x48, 0x69, 0xD9, 0x2A, 0xD8, 0x68, 0x55, 0xDA, 0x32, 0xD8, 0x50, 0x71, 0xD9,
			0x32, 0xD8, 0x70, 0x5D, 0xDA, 0x3A, 0xD8, 0x58, 0x79, 0xD9, 0x3A, 0xD8, 0x78, 0xA8, 0x8A, 0x9A,
			0xF0, 0x28, 0x50, 0x78, 0x9E, 0xF3, 0x88, 0x18, 0xF1, 0x9F, 0x1D, 0x98, 0xA8, 0xD9, 0x08, 0xD8,
			0xC8, 0x9F, 0x12, 0x9E, 0xF3, 0x15, 0xA8, 0xDA, 0x12, 0x10, 0xD8, 0xF1, 0xAF, 0xC8, 0x97, 0x87,

			// bank 5, 256 bytes
			0x34, 0xB5, 0xB9, 0x94, 0xA4, 0x21, 0xF3, 0xD9, 0x22, 0xD8, 0xF2, 0x2D, 0xF3, 0xD9, 0x2A, 0xD8,
			0xF2, 0x35, 0xF3, 0xD9, 0x32, 0xD8, 0x81, 0xA4, 0x60, 0x60, 0x61, 0xD9, 0x61, 0xD8, 0x6C, 0x68,
			0x69, 0xD9, 0x69, 0xD8, 0x74, 0x70, 0x71, 0xD9, 0x71, 0xD8, 0xB1, 0xA3, 0x84, 0x19, 0x3D, 0x5D,
			0xA3, 0x83, 0x1A, 0x3E, 0x5E, 0x93, 0x10, 0x30, 0x81, 0x10, 0x11, 0xB8, 0xB0, 0xAF, 0x8F, 0x94,
			0xF2, 0xDA, 0x3E, 0xD8, 0xB4, 0x9A, 0xA8, 0x87, 0x29, 0xDA, 0xF8, 0xD8, 0x87, 0x9A, 0x35, 0xDA,
			0xF8, 0xD8, 0x87, 0x9A, 0x3D, 0xDA, 0xF8, 0xD8, 0xB1, 0xB9, 0xA4, 0x98, 0x85, 0x02, 0x2E, 0x56,
			0xA5, 0x81, 0x00, 0x0C, 0x14, 0xA3, 0x97, 0xB0, 0x8A, 0xF1, 0x2D, 0xD9, 0x28, 0xD8, 0x4D, 0xD9,
			0x48, 0xD8, 0x6D, 0xD9, 0x68, 0xD8, 0xB1, 0x84, 0x0D, 0xDA, 0x0E, 0xD8, 0xA3, 0x29, 0x83, 0xDA,
			0x2C, 0x0E, 0xD8, 0xA3, 0x84, 0x49, 0x83, 0xDA, 0x2C, 0x4C, 0x0E, 0xD8, 0xB8, 0xB0, 0xA8, 0x8A,
			0x9A, 0xF5, 0x20, 0xAA, 0xDA, 0xDF, 0xD8, 0xA8, 0x40, 0xAA, 0xD0, 0xDA, 0xDE, 0xD8, 0xA8, 0x60,
			0xAA, 0xDA, 0xD0, 0xDF, 0xD8, 0xF1, 0x97, 0x86, 0xA8, 0x31, 0x9B, 0x06, 0x99, 0x07, 0xAB, 0x97,
			0x28, 0x88, 0x9B, 0xF0, 0x0C, 0x20, 0x14, 0x40, 0xB8, 0xB0, 0xB4, 0xA8, 0x8C, 0x9C, 0xF0, 0x04,
			0x28, 0x51, 0x79, 0x1D, 0x30, 0x14, 0x38, 0xB2, 0x82, 0xAB, 0xD0, 0x98, 0x2C, 0x50, 0x50, 0x78,
			0x78, 0x9B, 0xF1, 0x1A, 0xB0, 0xF0, 0x8A, 0x9C, 0xA8, 0x29, 0x51, 0x79, 0x8B, 0x29, 0x51, 0x79,
			0x8A, 0x24, 0x70, 0x59, 0x8B, 0x20, 0x58, 0x71, 0x8A, 0x44, 0x69, 0x38, 0x8B, 0x39, 0x40, 0x68,
			0x8A, 0x64, 0x48, 0x31, 0x8B, 0x30, 0x49, 0x60, 0xA5, 0x88, 0x20, 0x09, 0x71, 0x58, 0x44, 0x68,

			// bank 6, 256 bytes
			0x11, 0x39, 0x64, 0x49, 0x30, 0x19, 0xF1, 0xAC, 0x00, 0x2C, 0x54, 0x7C, 0xF0, 0x8C, 0xA8, 0x04,
			0x28, 0x50, 0x78, 0xF1, 0x88, 0x97, 0x26, 0xA8, 0x59, 0x98, 0xAC, 0x8C, 0x02, 0x26, 0x46, 0x66,
			0xF0, 0x89, 0x9C, 0xA8, 0x29, 0x51, 0x79, 0x24, 0x70, 0x59, 0x44, 0x69, 0x38, 0x64, 0x48, 0x31,
			0xA9, 0x88, 0x09, 0x20, 0x59, 0x70, 0xAB, 0x11, 0x38, 0x40, 0x69, 0xA8, 0x19, 0x31, 0x48, 0x60,
			0x8C, 0xA8, 0x3C, 0x41, 0x5C, 0x20, 0x7C, 0x00, 0xF1, 0x87, 0x98, 0x19, 0x86, 0xA8, 0x6E, 0x76,
			0x7E, 0xA9, 0x99, 0x88, 0x2D, 0x55, 0x7D, 0x9E, 0xB9, 0xA3, 0x8A, 0x22, 0x8A, 0x6E, 0x8A, 0x56,
			0x8A, 0x5E, 0x9F, 0xB1, 0x83, 0x06, 0x26, 0x46, 0x66, 0x0E, 0x2E, 0x4E, 0x6E, 0x9D, 0xB8, 0xAD,
			0x00, 0x2C, 0x54, 0x7C, 0xF2, 0xB1, 0x8C, 0xB4, 0x99, 0xB9, 0xA3, 0x2D, 0x55, 0x7D, 0x81, 0x91,
			0xAC, 0x38, 0xAD, 0x3A, 0xB5, 0x83, 0x91, 0xAC, 0x2D, 0xD9, 0x28, 0xD8, 0x4D, 0xD9, 0x48, 0xD8,
			0x6D, 0xD9, 0x68, 0xD8, 0x8C, 0x9D, 0xAE, 0x29, 0xD9, 0x04, 0xAE, 0xD8, 0x51, 0xD9, 0x04, 0xAE,
			0xD8, 0x79, 0xD9, 0x04, 0xD8, 0x81, 0xF3, 0x9D, 0xAD, 0x00, 0x8D, 0xAE, 0x19, 0x81, 0xAD, 0xD9,
			0x01, 0xD8, 0xF2, 0xAE, 0xDA, 0x26, 0xD8, 0x8E, 0x91, 0x29, 0x83, 0xA7, 0xD9, 0xAD, 0xAD, 0xAD,
			0xAD, 0xF3, 0x2A, 0xD8, 0xD8, 0xF1, 0xB0, 0xAC, 0x89, 0x91, 0x3E, 0x5E, 0x76, 0xF3, 0xAC, 0x2E,
			0x2E, 0xF1, 0xB1, 0x8C, 0x5A, 0x9C, 0xAC, 0x2C, 0x28, 0x28, 0x28, 0x9C, 0xAC, 0x30, 0x18, 0xA8,
			0x98, 0x81, 0x28, 0x34, 0x3C, 0x97, 0x24, 0xA7, 0x28, 0x34, 0x3C, 0x9C, 0x24, 0xF2, 0xB0, 0x89,
			0xAC, 0x91, 0x2C, 0x4C, 0x6C, 0x8A, 0x9B, 0x2D, 0xD9, 0xD8, 0xD8, 0x51, 0xD9, 0xD8, 0xD8, 0x79,

			// bank 7, 138 bytes (remainder)
			0xD9, 0xD8, 0xD8, 0xF1, 0x9E, 0x88, 0xA3, 0x31, 0xDA, 0xD8, 0xD8, 0x91, 0x2D, 0xD9, 0x28, 0xD8,
			0x4D, 0xD9, 0x48, 0xD8, 0x6D, 0xD9, 0x68, 0xD8, 0xB1, 0x83, 0x93, 0x35, 0x3D, 0x80, 0x25, 0xDA,
			0xD8, 0xD8, 0x85, 0x69, 0xDA, 0xD8, 0xD8, 0xB4, 0x93, 0x81, 0xA3, 0x28, 0x34, 0x3C, 0xF3, 0xAB,
			0x8B, 0xF8, 0xA3, 0x91, 0xB6, 0x09, 0xB4, 0xD9, 0xAB, 0xDE, 0xFA, 0xB0, 0x87, 0x9C, 0xB9, 0xA3,
			0xDD, 0xF1, 0xA3, 0xA3, 0xA3, 0xA3, 0x95, 0xF1, 0xA3, 0xA3, 0xA3, 0x9D, 0xF1, 0xA3, 0xA3, 0xA3,
			0xA3, 0xF2, 0xA3, 0xB4, 0x90, 0x80, 0xF2, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3,
			0xA3, 0xB2, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xB0, 0x87, 0xB5, 0x99, 0xF1, 0xA3, 0xA3, 0xA3,
			0x98, 0xF1, 0xA3, 0xA3, 0xA3, 0xA3, 0x97, 0xA3, 0xA3, 0xA3, 0xA3, 0xF3, 0x9B, 0xA3, 0xA3, 0xDC,
			0xB9, 0xA7, 0xF1, 0x26, 0x26, 0x26, 0xD8, 0xD8, 0xFF
		};

		private static readonly byte[] DmpConfig6 =
		{
			//  BANK    OFFSET  LENGTH  [DATA]
			0x03,   0x7B,   0x03,   0x4C, 0xCD, 0x6C,         // FCFG_1 inv_set_gyro_calibration
			0x03,   0xAB,   0x03,   0x36, 0x56, 0x76,         // FCFG_3 inv_set_gyro_calibration
			0x00,   0x68,   0x04,   0x02, 0xCB, 0x47, 0xA2,   // D_0_104 inv_set_gyro_calibration
			0x02,   0x18,   0x04,   0x00, 0x05, 0x8B, 0xC1,   // D_0_24 inv_set_gyro_calibration
			0x01,   0x0C,   0x04,   0x00, 0x00, 0x00, 0x00,   // D_1_152 inv_set_accel_calibration
			0x03,   0x7F,   0x06,   0x0C, 0xC9, 0x2C, 0x97, 0x97, 0x97, // FCFG_2 inv_set_accel_calibration
			0x03,   0x89,   0x03,   0x26, 0x46, 0x66,         // FCFG_7 inv_set_accel_calibration
			0x00,   0x6C,   0x02,   0x20, 0x00,               // D_0_108 inv_set_accel_calibration
			0x02,   0x40,   0x04,   0x00, 0x00, 0x00, 0x00,   // CPASS_MTX_00 inv_set_compass_calibration
			0x02,   0x44,   0x04,   0x00, 0x00, 0x00, 0x00,   // CPASS_MTX_01
			0x02,   0x48,   0x04,   0x00, 0x00, 0x00, 0x00,   // CPASS_MTX_02
			0x02,   0x4C,   0x04,   0x00, 0x00, 0x00, 0x00,   // CPASS_MTX_10
			0x02,   0x50,   0x04,   0x00, 0x00, 0x00, 0x00,   // CPASS_MTX_11
			0x02,   0x54,   0x04,   0x00, 0x00, 0x00, 0x00,   // CPASS_MTX_12
			0x02,   0x58,   0x04,   0x00, 0x00, 0x00, 0x00,   // CPASS_MTX_20
			0x02,   0x5C,   0x04,   0x00, 0x00, 0x00, 0x00,   // CPASS_MTX_21
			0x02,   0xBC,   0x04,   0x00, 0x00, 0x00, 0x00,   // CPASS_MTX_22
			0x01,   0xEC,   0x04,   0x00, 0x00, 0x40, 0x00,   // D_1_236 inv_apply_endian_accel
			0x03,   0x7F,   0x06,   0x0C, 0xC9, 0x2C, 0x97, 0x97, 0x97, // FCFG_2 inv_set_mpu_sensors
			0x04,   0x02,   0x03,   0x0D, 0x35, 0x5D,         // CFG_MOTION_BIAS inv_turn_on_bias_from_no_motion
			0x04,   0x09,   0x04,   0x87, 0x2D, 0x35, 0x3D,   // FCFG_5 inv_set_bias_update
			0x00,   0xA3,   0x01,   0x00,                     // D_0_163 inv_set_dead_zone
						 // SPECIAL 0x01 = enable interrupts
			0x00,   0x00,   0x00,   0x01, // SET INT_ENABLE at i=22, SPECIAL INSTRUCTION
			0x07,   0x86,   0x01,   0xFE,                     // CFG_6 inv_set_fifo_interupt
			0x07,   0x41,   0x05,   0xF1, 0x20, 0x28, 0x30, 0x38, // CFG_8 inv_send_quaternion
			0x07,   0x7E,   0x01,   0x30,                     // CFG_16 inv_set_footer
			0x07,   0x46,   0x01,   0x9A,                     // CFG_GYRO_SOURCE inv_send_gyro
			0x07,   0x47,   0x04,   0xF1, 0x28, 0x30, 0x38,   // CFG_9 inv_send_gyro -> inv_construct3_fifo
			0x07,   0x6C,   0x04,   0xF1, 0x28, 0x30, 0x38,   // CFG_12 inv_send_accel -> inv_construct3_fifo
			0x02,   0x16,   0x02,   0x00, 0x01                // D_0_22 inv_set_fifo_rate

			// This very last 0x01 WAS a 0x09, which drops the FIFO rate down to 20 Hz. 0x07 is 25 Hz,
			// 0x01 is 100Hz. Going faster than 100Hz (0x00=200Hz) tends to result in very noisy data.
			// DMP output frequency is calculated easily using this equation: (200Hz / (1 + value))

			// It is important to make sure the host processor can keep up with reading and processing
			// the FIFO output at the desired rate. Handling FIFO overflow cleanly is also a good idea.
		};

		private static readonly byte[] DmpUpdates6 =
		{
			0x01,   0xB2,   0x02,   0xFF, 0xFF,
			0x01,   0x90,   0x04,   0x09, 0x23, 0xA1, 0x35,
			0x01,   0x6A,   0x02,   0x06, 0x00,
			0x01,   0x60,   0x08,   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00,   0x60,   0x04,   0x40, 0x00, 0x00, 0x00,
			0x01,   0x62,   0x02,   0x00, 0x00,
			0x00,   0x60,   0x04,   0x00, 0x40, 0x00, 0x00
		};

		private static readonly byte[] DmpMemory9 =
		{
			// bank 0, 256 bytes
			0xFB, 0x00, 0x00, 0x3E, 0x00, 0x0B, 0x00, 0x36, 0x00, 0x01, 0x00, 0x02, 0x00, 0x03, 0x00, 0x00,
			0x00, 0x65, 0x00, 0x54, 0xFF, 0xEF, 0x00, 0x00, 0xFA, 0x80, 0x00, 0x0B, 0x12, 0x82, 0x00, 0x01,
			0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x28, 0x00, 0x00, 0xFF, 0xFF, 0x45, 0x81, 0xFF, 0xFF, 0xFA, 0x72, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x03, 0xE8, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x7F, 0xFF, 0xFF, 0xFE, 0x80, 0x01,
			0x00, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x3E, 0x03, 0x30, 0x40, 0x00, 0x00, 0x00, 0x02, 0xCA, 0xE3, 0x09, 0x3E, 0x80, 0x00, 0x00,
			0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00,
			0x41, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x0B, 0x2A, 0x00, 0x00, 0x16, 0x55, 0x00, 0x00, 0x21, 0x82,
			0xFD, 0x87, 0x26, 0x50, 0xFD, 0x80, 0x00, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x00, 0x05, 0x80, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00,
			0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x6F, 0x00, 0x02, 0x65, 0x32, 0x00, 0x00, 0x5E, 0xC0,
			0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xFB, 0x8C, 0x6F, 0x5D, 0xFD, 0x5D, 0x08, 0xD9, 0x00, 0x7C, 0x73, 0x3B, 0x00, 0x6C, 0x12, 0xCC,
			0x32, 0x00, 0x13, 0x9D, 0x32, 0x00, 0xD0, 0xD6, 0x32, 0x00, 0x08, 0x00, 0x40, 0x00, 0x01, 0xF4,
			0xFF, 0xE6, 0x80, 0x79, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD0, 0xD6, 0x00, 0x00, 0x27, 0x10,

			// bank 1, 256 bytes
			0xFB, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00,
			0x00, 0x00, 0xFA, 0x36, 0xFF, 0xBC, 0x30, 0x8E, 0x00, 0x05, 0xFB, 0xF0, 0xFF, 0xD9, 0x5B, 0xC8,
			0xFF, 0xD0, 0x9A, 0xBE, 0x00, 0x00, 0x10, 0xA9, 0xFF, 0xF4, 0x1E, 0xB2, 0x00, 0xCE, 0xBB, 0xF7,
			0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x02, 0x00, 0x02, 0x02, 0x00, 0x00, 0x0C,
			0xFF, 0xC2, 0x80, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0xCF, 0x80, 0x00, 0x40, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x14,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x03, 0x3F, 0x68, 0xB6, 0x79, 0x35, 0x28, 0xBC, 0xC6, 0x7E, 0xD1, 0x6C,
			0x80, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB2, 0x6A, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3F, 0xF0, 0x00, 0x00, 0x00, 0x30,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x25, 0x4D, 0x00, 0x2F, 0x70, 0x6D, 0x00, 0x00, 0x05, 0xAE, 0x00, 0x0C, 0x02, 0xD0,
    
			// bank 2, 256 bytes
			0x00, 0x00, 0x00, 0x00, 0x00, 0x65, 0x00, 0x54, 0xFF, 0xEF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x01, 0x00, 0x00, 0x44, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x01, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x65, 0x00, 0x00, 0x00, 0x54, 0x00, 0x00, 0xFF, 0xEF, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,
			0x00, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x47, 0x78, 0xA2,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    
			// bank 3, 256 bytes
			0xD8, 0xDC, 0xF4, 0xD8, 0xB9, 0xAB, 0xF3, 0xF8, 0xFA, 0xF1, 0xBA, 0xA2, 0xDE, 0xB2, 0xB8, 0xB4,
			0xA8, 0x81, 0x98, 0xF7, 0x4A, 0x90, 0x7F, 0x91, 0x6A, 0xF3, 0xF9, 0xDB, 0xA8, 0xF9, 0xB0, 0xBA,
			0xA0, 0x80, 0xF2, 0xCE, 0x81, 0xF3, 0xC2, 0xF1, 0xC1, 0xF2, 0xC3, 0xF3, 0xCC, 0xA2, 0xB2, 0x80,
			0xF1, 0xC6, 0xD8, 0x80, 0xBA, 0xA7, 0xDF, 0xDF, 0xDF, 0xF2, 0xA7, 0xC3, 0xCB, 0xC5, 0xB6, 0xF0,
			0x87, 0xA2, 0x94, 0x24, 0x48, 0x70, 0x3C, 0x95, 0x40, 0x68, 0x34, 0x58, 0x9B, 0x78, 0xA2, 0xF1,
			0x83, 0x92, 0x2D, 0x55, 0x7D, 0xD8, 0xB1, 0xB4, 0xB8, 0xA1, 0xD0, 0x91, 0x80, 0xF2, 0x70, 0xF3,
			0x70, 0xF2, 0x7C, 0x80, 0xA8, 0xF1, 0x01, 0xB0, 0x98, 0x87, 0xD9, 0x43, 0xD8, 0x86, 0xC9, 0x88,
			0xBA, 0xA1, 0xF2, 0x0E, 0xB8, 0x97, 0x80, 0xF1, 0xA9, 0xDF, 0xDF, 0xDF, 0xAA, 0xDF, 0xDF, 0xDF,
			0xF2, 0xAA, 0xC5, 0xCD, 0xC7, 0xA9, 0x0C, 0xC9, 0x2C, 0x97, 0x97, 0x97, 0x97, 0xF1, 0xA9, 0x89,
			0x26, 0x46, 0x66, 0xB0, 0xB4, 0xBA, 0x80, 0xAC, 0xDE, 0xF2, 0xCA, 0xF1, 0xB2, 0x8C, 0x02, 0xA9,
			0xB6, 0x98, 0x00, 0x89, 0x0E, 0x16, 0x1E, 0xB8, 0xA9, 0xB4, 0x99, 0x2C, 0x54, 0x7C, 0xB0, 0x8A,
			0xA8, 0x96, 0x36, 0x56, 0x76, 0xF1, 0xB9, 0xAF, 0xB4, 0xB0, 0x83, 0xC0, 0xB8, 0xA8, 0x97, 0x11,
			0xB1, 0x8F, 0x98, 0xB9, 0xAF, 0xF0, 0x24, 0x08, 0x44, 0x10, 0x64, 0x18, 0xF1, 0xA3, 0x29, 0x55,
			0x7D, 0xAF, 0x83, 0xB5, 0x93, 0xF0, 0x00, 0x28, 0x50, 0xF5, 0xBA, 0xAD, 0x8F, 0x9F, 0x28, 0x54,
			0x7C, 0xB9, 0xF1, 0xA3, 0x86, 0x9F, 0x61, 0xA6, 0xDA, 0xDE, 0xDF, 0xDB, 0xB2, 0xB6, 0x8E, 0x9D,
			0xAE, 0xF5, 0x60, 0x68, 0x70, 0xB1, 0xB5, 0xF1, 0xDA, 0xA6, 0xDF, 0xD9, 0xA6, 0xFA, 0xA3, 0x86,
    
			// bank 4, 256 bytes
			0x96, 0xDB, 0x31, 0xA6, 0xD9, 0xF8, 0xDF, 0xBA, 0xA6, 0x8F, 0xC2, 0xC5, 0xC7, 0xB2, 0x8C, 0xC1,
			0xB8, 0xA2, 0xDF, 0xDF, 0xDF, 0xA3, 0xDF, 0xDF, 0xDF, 0xD8, 0xD8, 0xF1, 0xB8, 0xA8, 0xB2, 0x86,
			0xB4, 0x98, 0x0D, 0x35, 0x5D, 0xB8, 0xAA, 0x98, 0xB0, 0x87, 0x2D, 0x35, 0x3D, 0xB2, 0xB6, 0xBA,
			0xAF, 0x8C, 0x96, 0x19, 0x8F, 0x9F, 0xA7, 0x0E, 0x16, 0x1E, 0xB4, 0x9A, 0xB8, 0xAA, 0x87, 0x2C,
			0x54, 0x7C, 0xB9, 0xA3, 0xDE, 0xDF, 0xDF, 0xA3, 0xB1, 0x80, 0xF2, 0xC4, 0xCD, 0xC9, 0xF1, 0xB8,
			0xA9, 0xB4, 0x99, 0x83, 0x0D, 0x35, 0x5D, 0x89, 0xB9, 0xA3, 0x2D, 0x55, 0x7D, 0xB5, 0x93, 0xA3,
			0x0E, 0x16, 0x1E, 0xA9, 0x2C, 0x54, 0x7C, 0xB8, 0xB4, 0xB0, 0xF1, 0x97, 0x83, 0xA8, 0x11, 0x84,
			0xA5, 0x09, 0x98, 0xA3, 0x83, 0xF0, 0xDA, 0x24, 0x08, 0x44, 0x10, 0x64, 0x18, 0xD8, 0xF1, 0xA5,
			0x29, 0x55, 0x7D, 0xA5, 0x85, 0x95, 0x02, 0x1A, 0x2E, 0x3A, 0x56, 0x5A, 0x40, 0x48, 0xF9, 0xF3,
			0xA3, 0xD9, 0xF8, 0xF0, 0x98, 0x83, 0x24, 0x08, 0x44, 0x10, 0x64, 0x18, 0x97, 0x82, 0xA8, 0xF1,
			0x11, 0xF0, 0x98, 0xA2, 0x24, 0x08, 0x44, 0x10, 0x64, 0x18, 0xDA, 0xF3, 0xDE, 0xD8, 0x83, 0xA5,
			0x94, 0x01, 0xD9, 0xA3, 0x02, 0xF1, 0xA2, 0xC3, 0xC5, 0xC7, 0xD8, 0xF1, 0x84, 0x92, 0xA2, 0x4D,
			0xDA, 0x2A, 0xD8, 0x48, 0x69, 0xD9, 0x2A, 0xD8, 0x68, 0x55, 0xDA, 0x32, 0xD8, 0x50, 0x71, 0xD9,
			0x32, 0xD8, 0x70, 0x5D, 0xDA, 0x3A, 0xD8, 0x58, 0x79, 0xD9, 0x3A, 0xD8, 0x78, 0x93, 0xA3, 0x4D,
			0xDA, 0x2A, 0xD8, 0x48, 0x69, 0xD9, 0x2A, 0xD8, 0x68, 0x55, 0xDA, 0x32, 0xD8, 0x50, 0x71, 0xD9,
			0x32, 0xD8, 0x70, 0x5D, 0xDA, 0x3A, 0xD8, 0x58, 0x79, 0xD9, 0x3A, 0xD8, 0x78, 0xA8, 0x8A, 0x9A,
    
			// bank 5, 256 bytes
			0xF0, 0x28, 0x50, 0x78, 0x9E, 0xF3, 0x88, 0x18, 0xF1, 0x9F, 0x1D, 0x98, 0xA8, 0xD9, 0x08, 0xD8,
			0xC8, 0x9F, 0x12, 0x9E, 0xF3, 0x15, 0xA8, 0xDA, 0x12, 0x10, 0xD8, 0xF1, 0xAF, 0xC8, 0x97, 0x87,
			0x34, 0xB5, 0xB9, 0x94, 0xA4, 0x21, 0xF3, 0xD9, 0x22, 0xD8, 0xF2, 0x2D, 0xF3, 0xD9, 0x2A, 0xD8,
			0xF2, 0x35, 0xF3, 0xD9, 0x32, 0xD8, 0x81, 0xA4, 0x60, 0x60, 0x61, 0xD9, 0x61, 0xD8, 0x6C, 0x68,
			0x69, 0xD9, 0x69, 0xD8, 0x74, 0x70, 0x71, 0xD9, 0x71, 0xD8, 0xB1, 0xA3, 0x84, 0x19, 0x3D, 0x5D,
			0xA3, 0x83, 0x1A, 0x3E, 0x5E, 0x93, 0x10, 0x30, 0x81, 0x10, 0x11, 0xB8, 0xB0, 0xAF, 0x8F, 0x94,
			0xF2, 0xDA, 0x3E, 0xD8, 0xB4, 0x9A, 0xA8, 0x87, 0x29, 0xDA, 0xF8, 0xD8, 0x87, 0x9A, 0x35, 0xDA,
			0xF8, 0xD8, 0x87, 0x9A, 0x3D, 0xDA, 0xF8, 0xD8, 0xB1, 0xB9, 0xA4, 0x98, 0x85, 0x02, 0x2E, 0x56,
			0xA5, 0x81, 0x00, 0x0C, 0x14, 0xA3, 0x97, 0xB0, 0x8A, 0xF1, 0x2D, 0xD9, 0x28, 0xD8, 0x4D, 0xD9,
			0x48, 0xD8, 0x6D, 0xD9, 0x68, 0xD8, 0xB1, 0x84, 0x0D, 0xDA, 0x0E, 0xD8, 0xA3, 0x29, 0x83, 0xDA,
			0x2C, 0x0E, 0xD8, 0xA3, 0x84, 0x49, 0x83, 0xDA, 0x2C, 0x4C, 0x0E, 0xD8, 0xB8, 0xB0, 0x97, 0x86,
			0xA8, 0x31, 0x9B, 0x06, 0x99, 0x07, 0xAB, 0x97, 0x28, 0x88, 0x9B, 0xF0, 0x0C, 0x20, 0x14, 0x40,
			0xB9, 0xA3, 0x8A, 0xC3, 0xC5, 0xC7, 0x9A, 0xA3, 0x28, 0x50, 0x78, 0xF1, 0xB5, 0x93, 0x01, 0xD9,
			0xDF, 0xDF, 0xDF, 0xD8, 0xB8, 0xB4, 0xA8, 0x8C, 0x9C, 0xF0, 0x04, 0x28, 0x51, 0x79, 0x1D, 0x30,
			0x14, 0x38, 0xB2, 0x82, 0xAB, 0xD0, 0x98, 0x2C, 0x50, 0x50, 0x78, 0x78, 0x9B, 0xF1, 0x1A, 0xB0,
			0xF0, 0xB1, 0x83, 0x9C, 0xA8, 0x29, 0x51, 0x79, 0xB0, 0x8B, 0x29, 0x51, 0x79, 0xB1, 0x83, 0x24,

			// bank 6, 256 bytes
			0x70, 0x59, 0xB0, 0x8B, 0x20, 0x58, 0x71, 0xB1, 0x83, 0x44, 0x69, 0x38, 0xB0, 0x8B, 0x39, 0x40,
			0x68, 0xB1, 0x83, 0x64, 0x48, 0x31, 0xB0, 0x8B, 0x30, 0x49, 0x60, 0xA5, 0x88, 0x20, 0x09, 0x71,
			0x58, 0x44, 0x68, 0x11, 0x39, 0x64, 0x49, 0x30, 0x19, 0xF1, 0xAC, 0x00, 0x2C, 0x54, 0x7C, 0xF0,
			0x8C, 0xA8, 0x04, 0x28, 0x50, 0x78, 0xF1, 0x88, 0x97, 0x26, 0xA8, 0x59, 0x98, 0xAC, 0x8C, 0x02,
			0x26, 0x46, 0x66, 0xF0, 0x89, 0x9C, 0xA8, 0x29, 0x51, 0x79, 0x24, 0x70, 0x59, 0x44, 0x69, 0x38,
			0x64, 0x48, 0x31, 0xA9, 0x88, 0x09, 0x20, 0x59, 0x70, 0xAB, 0x11, 0x38, 0x40, 0x69, 0xA8, 0x19,
			0x31, 0x48, 0x60, 0x8C, 0xA8, 0x3C, 0x41, 0x5C, 0x20, 0x7C, 0x00, 0xF1, 0x87, 0x98, 0x19, 0x86,
			0xA8, 0x6E, 0x76, 0x7E, 0xA9, 0x99, 0x88, 0x2D, 0x55, 0x7D, 0x9E, 0xB9, 0xA3, 0x8A, 0x22, 0x8A,
			0x6E, 0x8A, 0x56, 0x8A, 0x5E, 0x9F, 0xB1, 0x83, 0x06, 0x26, 0x46, 0x66, 0x0E, 0x2E, 0x4E, 0x6E,
			0x9D, 0xB8, 0xAD, 0x00, 0x2C, 0x54, 0x7C, 0xF2, 0xB1, 0x8C, 0xB4, 0x99, 0xB9, 0xA3, 0x2D, 0x55,
			0x7D, 0x81, 0x91, 0xAC, 0x38, 0xAD, 0x3A, 0xB5, 0x83, 0x91, 0xAC, 0x2D, 0xD9, 0x28, 0xD8, 0x4D,
			0xD9, 0x48, 0xD8, 0x6D, 0xD9, 0x68, 0xD8, 0x8C, 0x9D, 0xAE, 0x29, 0xD9, 0x04, 0xAE, 0xD8, 0x51,
			0xD9, 0x04, 0xAE, 0xD8, 0x79, 0xD9, 0x04, 0xD8, 0x81, 0xF3, 0x9D, 0xAD, 0x00, 0x8D, 0xAE, 0x19,
			0x81, 0xAD, 0xD9, 0x01, 0xD8, 0xF2, 0xAE, 0xDA, 0x26, 0xD8, 0x8E, 0x91, 0x29, 0x83, 0xA7, 0xD9,
			0xAD, 0xAD, 0xAD, 0xAD, 0xF3, 0x2A, 0xD8, 0xD8, 0xF1, 0xB0, 0xAC, 0x89, 0x91, 0x3E, 0x5E, 0x76,
			0xF3, 0xAC, 0x2E, 0x2E, 0xF1, 0xB1, 0x8C, 0x5A, 0x9C, 0xAC, 0x2C, 0x28, 0x28, 0x28, 0x9C, 0xAC,
    
			// bank 7, 170 bytes (remainder)
			0x30, 0x18, 0xA8, 0x98, 0x81, 0x28, 0x34, 0x3C, 0x97, 0x24, 0xA7, 0x28, 0x34, 0x3C, 0x9C, 0x24,
			0xF2, 0xB0, 0x89, 0xAC, 0x91, 0x2C, 0x4C, 0x6C, 0x8A, 0x9B, 0x2D, 0xD9, 0xD8, 0xD8, 0x51, 0xD9,
			0xD8, 0xD8, 0x79, 0xD9, 0xD8, 0xD8, 0xF1, 0x9E, 0x88, 0xA3, 0x31, 0xDA, 0xD8, 0xD8, 0x91, 0x2D,
			0xD9, 0x28, 0xD8, 0x4D, 0xD9, 0x48, 0xD8, 0x6D, 0xD9, 0x68, 0xD8, 0xB1, 0x83, 0x93, 0x35, 0x3D,
			0x80, 0x25, 0xDA, 0xD8, 0xD8, 0x85, 0x69, 0xDA, 0xD8, 0xD8, 0xB4, 0x93, 0x81, 0xA3, 0x28, 0x34,
			0x3C, 0xF3, 0xAB, 0x8B, 0xA3, 0x91, 0xB6, 0x09, 0xB4, 0xD9, 0xAB, 0xDE, 0xB0, 0x87, 0x9C, 0xB9,
			0xA3, 0xDD, 0xF1, 0xA3, 0xA3, 0xA3, 0xA3, 0x95, 0xF1, 0xA3, 0xA3, 0xA3, 0x9D, 0xF1, 0xA3, 0xA3,
			0xA3, 0xA3, 0xF2, 0xA3, 0xB4, 0x90, 0x80, 0xF2, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3,
			0xA3, 0xA3, 0xB2, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xB0, 0x87, 0xB5, 0x99, 0xF1, 0xA3, 0xA3,
			0xA3, 0x98, 0xF1, 0xA3, 0xA3, 0xA3, 0xA3, 0x97, 0xA3, 0xA3, 0xA3, 0xA3, 0xF3, 0x9B, 0xA3, 0xA3,
			0xDC, 0xB9, 0xA7, 0xF1, 0x26, 0x26, 0x26, 0xD8, 0xD8, 0xFF
		};

		private static readonly byte[] DmpConfig9 =
		{
			//  BANK    OFFSET  LENGTH  [DATA]
			0x02, 0xEC, 0x04, 0x00, 0x47, 0x7D, 0x1A, // ?
			0x03, 0x82, 0x03, 0x4C, 0xCD, 0x6C, // FCFG_1 inv_set_gyro_calibration
			0x03, 0xB2, 0x03, 0x36, 0x56, 0x76, // FCFG_3 inv_set_gyro_calibration
			0x00, 0x68, 0x04, 0x02, 0xCA, 0xE3, 0x09, // D_0_104 inv_set_gyro_calibration
			0x01, 0x0C, 0x04, 0x00, 0x00, 0x00, 0x00, // D_1_152 inv_set_accel_calibration
			0x03, 0x86, 0x03, 0x0C, 0xC9, 0x2C, // FCFG_2 inv_set_accel_calibration
			0x03, 0x90, 0x03, 0x26, 0x46, 0x66, //   (continued)...FCFG_2 inv_set_accel_calibration
			0x00, 0x6C, 0x02, 0x40, 0x00, // D_0_108 inv_set_accel_calibration

			0x02, 0x40, 0x04, 0x00, 0x00, 0x00, 0x00, // CPASS_MTX_00 inv_set_compass_calibration
			0x02, 0x44, 0x04, 0x40, 0x00, 0x00, 0x00, // CPASS_MTX_01
			0x02, 0x48, 0x04, 0x00, 0x00, 0x00, 0x00, // CPASS_MTX_02
			0x02, 0x4C, 0x04, 0x40, 0x00, 0x00, 0x00, // CPASS_MTX_10
			0x02, 0x50, 0x04, 0x00, 0x00, 0x00, 0x00, // CPASS_MTX_11
			0x02, 0x54, 0x04, 0x00, 0x00, 0x00, 0x00, // CPASS_MTX_12
			0x02, 0x58, 0x04, 0x00, 0x00, 0x00, 0x00, // CPASS_MTX_20
			0x02, 0x5C, 0x04, 0x00, 0x00, 0x00, 0x00, // CPASS_MTX_21
			0x02, 0xBC, 0x04, 0xC0, 0x00, 0x00, 0x00, // CPASS_MTX_22

			0x01, 0xEC, 0x04, 0x00, 0x00, 0x40, 0x00, // D_1_236 inv_apply_endian_accel
			0x03, 0x86, 0x06, 0x0C, 0xC9, 0x2C, 0x97, 0x97, 0x97, // FCFG_2 inv_set_mpu_sensors
			0x04, 0x22, 0x03, 0x0D, 0x35, 0x5D, // CFG_MOTION_BIAS inv_turn_on_bias_from_no_motion
			0x00, 0xA3, 0x01, 0x00, // ?
			0x04, 0x29, 0x04, 0x87, 0x2D, 0x35, 0x3D, // FCFG_5 inv_set_bias_update
			0x07, 0x62, 0x05, 0xF1, 0x20, 0x28, 0x30, 0x38, // CFG_8 inv_send_quaternion
			0x07, 0x9F, 0x01, 0x30, // CFG_16 inv_set_footer
			0x07, 0x67, 0x01, 0x9A, // CFG_GYRO_SOURCE inv_send_gyro
			0x07, 0x68, 0x04, 0xF1, 0x28, 0x30, 0x38, // CFG_9 inv_send_gyro -> inv_construct3_fifo
			0x07, 0x62, 0x05, 0xF1, 0x20, 0x28, 0x30, 0x38, // ?
			0x02, 0x0C, 0x04, 0x00, 0x00, 0x00, 0x00, // ?
			0x07, 0x83, 0x06, 0xC2, 0xCA, 0xC4, 0xA3, 0xA3, 0xA3, // ?
			// SPECIAL 0x01 = enable interrupts
			0x00, 0x00, 0x00, 0x01, // SET INT_ENABLE, SPECIAL INSTRUCTION
			0x07, 0xA7, 0x01, 0xFE, // ?
			0x07, 0x62, 0x05, 0xF1, 0x20, 0x28, 0x30, 0x38, // ?
			0x07, 0x67, 0x01, 0x9A, // ?
			0x07, 0x68, 0x04, 0xF1, 0x28, 0x30, 0x38, // CFG_12 inv_send_accel -> inv_construct3_fifo
			0x07, 0x8D, 0x04, 0xF1, 0x28, 0x30, 0x38, // ??? CFG_12 inv_send_mag -> inv_construct3_fifo
			0x02, 0x16, 0x02, 0x00, 0x01 // D_0_22 inv_set_fifo_rate

			// This very last 0x01 WAS a 0x09, which drops the FIFO rate down to 20 Hz. 0x07 is 25 Hz,
			// 0x01 is 100Hz. Going faster than 100Hz (0x00=200Hz) tends to result in very noisy data.
			// DMP output frequency is calculated easily using this equation: (200Hz / (1 + value))

			// It is important to make sure the host processor can keep up with reading and processing
			// the FIFO output at the desired rate. Handling FIFO overflow cleanly is also a good idea.
		};

		private static readonly byte[] DmpUpdates9 =
		{
			0x01,   0xB2,   0x02,   0xFF, 0xF5,
			0x01,   0x90,   0x04,   0x0A, 0x0D, 0x97, 0xC0,
			0x00,   0xA3,   0x01,   0x00,
			0x04,   0x29,   0x04,   0x87, 0x2D, 0x35, 0x3D,
			0x01,   0x6A,   0x02,   0x06, 0x00,
			0x01,   0x60,   0x08,   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00,   0x60,   0x04,   0x40, 0x00, 0x00, 0x00,
			0x02,   0x60,   0x0C,   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x01,   0x08,   0x02,   0x01, 0x20,
			0x01,   0x0A,   0x02,   0x00, 0x4E,
			0x01,   0x02,   0x02,   0xFE, 0xB3,
			0x02,   0x6C,   0x04,   0x00, 0x00, 0x00, 0x00, // READ
			0x02,   0x6C,   0x04,   0xFA, 0xFE, 0x00, 0x00,
			0x02,   0x60,   0x0C,   0xFF, 0xFF, 0xCB, 0x4D, 0x00, 0x01, 0x08, 0xC1, 0xFF, 0xFF, 0xBC, 0x2C,
			0x02,   0xF4,   0x04,   0x00, 0x00, 0x00, 0x00,
			0x02,   0xF8,   0x04,   0x00, 0x00, 0x00, 0x00,
			0x02,   0xFC,   0x04,   0x00, 0x00, 0x00, 0x00,
			0x00,   0x60,   0x04,   0x40, 0x00, 0x00, 0x00,
			0x00,   0x60,   0x04,   0x00, 0x40, 0x00, 0x00
		};

		private static double _lastAngle;
		private static I2CDevice _imu;
		private static I2CDevice.Configuration _imuConfig;
		private static PWM _pwm1;
		private static PWM _pwm2;
		private static PidController _pid;
		private static int _pos;
		private static Filter _lowPassFilter;

		private const int PwmPeriode = 20000;

		private static SerialPort _gps;
		private static PwmInput _pwmInput;
		private static I2CDevice.Configuration _motorConfig;
		private static int _fifoOffset;
		private static byte[] _fifoBuffer = new byte[184];

		private static void GpsOnDataReceived(object sender, SerialDataReceivedEventArgs serialDataReceivedEventArgs)
		{
			var buffer = new byte[_gps.BytesToRead];
			_gps.Read(buffer, 0, buffer.Length);
			Debug.Print(buffer.Length.ToString());
		}

		public static void Main()
		{
			/*_gps = new SerialPort("COM3", 9600);
			_gps.DataReceived += GpsOnDataReceived;
			_gps.ReadTimeout = Timeout.Infinite;
			_gps.Open();

			Thread.Sleep(int.MaxValue);*/

			_pwmInput = new PwmInput(Pin.PB14);

			_pwm1 = new PWM(Cpu.PWMChannel.PWM_2, PwmPeriode, PwmPeriode / 20, PWM.ScaleFactor.Microseconds, false);
			_pwm1.Start();
			_pwm2 = new PWM(Cpu.PWMChannel.PWM_3, PwmPeriode, PwmPeriode / 20, PWM.ScaleFactor.Microseconds, false);
			_pwm2.Start();

			const double pKrit = -.006;
			const double tKrit = 2.1;
			var kp = .45 * pKrit;
			var tv = .12 * tKrit;
			var tn = .85 * tKrit;

			// working i=-.00005 p=-.0012 d=.002
			_pid = new PidController()
			{
				//Ki = -.0001,
				Kp = -.002,
				Kd = .002,
				OutputMinimum = -1,
				OutputMaximum = 1
			};

			//_lowPassFilter = new FilterButterworth(40, 100, FilterButterworth.PassType.Lowpass, 40);
			_lowPassFilter = new Filter(new[]
			{
				-0.000000, 
-0.008099, 
0.008097, 
0.012287, 
-0.029049, 
0.000000, 
0.059868, 
-0.054766, 
-0.088350, 
0.298459, 
0.600000, 
0.298459, 
-0.088350, 
-0.054766, 
0.059868, 
0.000000, 
-0.029049, 
0.012287, 
0.008097, 
-0.008099, 
-0.000000
			});

			/*var uart = new SerialPort("COM4", 38400, Parity.None, 8, StopBits.One);
			uart.DataReceived += uart_DataReceived;
			uart.Handshake = Handshake.None;
			uart.ReadTimeout = Timeout.Infinite;
			uart.Open();

			var data = Encoding.UTF8.GetBytes("\r\n+STWMOD=0\r\n");
			uart.Flush();
			uart.Write(data, 0, data.Length);

			Thread.Sleep(200);

			data = Encoding.UTF8.GetBytes("\r\n+STPIN=1234\r\n");
			uart.Flush();
			uart.Write(data, 0, data.Length);

			Thread.Sleep(200);

			data = Encoding.UTF8.GetBytes("\r\n+INQ=1\r\n");
			uart.Flush();
			uart.Write(data, 0, data.Length);
			uart.Flush();
			
			while (true)
			{
				String response = "";
				while (uart.BytesToRead > 0)
				{
					response = response + (char)uart.ReadByte();
				}
				if (response.Length > 0)
				{
					Debug.Print(response);

					//Check Bluetooth State Changed
					if (response.IndexOf("+BTSTATE:") > -1)
					{
						string atCommand = "+BTSTATE:";

						//String parsing  
						// Return format: +COPS:<mode>[,<format>,<oper>]
						int first = response.IndexOf(atCommand) + atCommand.Length;
						int last = response.IndexOf("\n", first);
						int state = int.Parse(((response.Substring(first, last - first)).Trim()));

						
					}
					//Check Pin Requested
					if (response.IndexOf("+INPIN") > -1)
					{
						// EDUARDO : Needs testing
						//OnPinRequested(this);
					}
					if (response.IndexOf("+RTINQ") > -1)
					{
						//EDUARDO: Needs testing

						string atCommand = "+RTINQ=";
						//String parsing  
						int first = response.IndexOf(atCommand) + atCommand.Length;
						int mid = response.IndexOf(";", first);
						int last = response.IndexOf("\r", first);

						// Keep reading until the end of the message
						while (last < 0)
						{
							while (uart.BytesToRead > 0)
							{
								response = response + (char)uart.ReadByte();
							}
							last = response.IndexOf("\r", first);
						}

						string address = ((response.Substring(first, mid - first)).Trim());

						string name = (response.Substring(mid + 1, last - mid));

						//OnDeviceInquired(this, address, name);
						//Debug.Print("Add: " + address + ", Name: " + name );
					}
					else
					{
						//OnDataReceived(this, response);
					}
				}
				Thread.Sleep(1);  //poundy changed from thread.sleep(10)
			}

			return;*/

			_imuConfig = new I2CDevice.Configuration(0x68, 400);
			var magConfig = new I2CDevice.Configuration(0x0E, 400);
			//_motorConfig = new I2CDevice.Configuration(0x40, 400);
			_imu = new I2CDevice(_imuConfig);

			/*WriteByte(_imu, _motorConfig, 0, 0); // reset
			Thread.Sleep(5);

			WriteBits(_imu, _motorConfig, 0, 4, 1, 1); //disable output
			WriteByte(_imu, _motorConfig, 0xFE, 121); // PRE_SCALE 11
			WriteBits(_imu, _motorConfig, 0, 5, 1, 1); // MODE1 autoincrement
			WriteBits(_imu, _motorConfig, 1, 2, 1, 1); // MODE2 OUTDRV = 0
			WriteBits(_imu, _motorConfig, 1, 4, 1, 0); // MODE2 INVRT = 1 ???
			WriteBits(_imu, _motorConfig, 0, 4, 1, 0); // enable output

			UInt16 on = 1;
			UInt16 off = (ushort)((double)4096 / 20);
			WriteBytes(_imu, _motorConfig, 0x6, new[] { (byte)on, (byte)(on >> 8), (byte)off, (byte)(off >> 8) });
			WriteBytes(_imu, _motorConfig, 0x6 + 4, new[] { (byte)on, (byte)(on >> 8), (byte)off, (byte)(off >> 8) });*/


			Debug.Print("Resetting MPU6050...");
			WriteBits(_imu, _imuConfig, MPU6050_RA_PWR_MGMT_1, MPU6050_PWR1_DEVICE_RESET_BIT, 1, 1);
			Thread.Sleep(30);

			var id = ReadBytes(_imu, _imuConfig, 0x75, 1);
			Debug.Print(id[0].ToString());

			Debug.Print("Disabling sleep mode...");
			DisableSleepMode(_imu, _imuConfig);

			Debug.Print("Selecting user bank 16...");
			SetMemoryBank(_imu, _imuConfig, 0x10, true, true);
			Debug.Print("Selecting memory byte 6...");
			SetMemoryStartAddress(_imu, _imuConfig, 0x06);

			Debug.Print("Resetting memory bank selection to 0...");
			SetMemoryBank(_imu, _imuConfig, 0, false, false);

			Debug.Print("Reading OTP bank valid flag...");
			var otpValid = GetOtpBankValid(_imu, _imuConfig);
			Debug.Print("OTP bank is " + (otpValid ? "valid" : "invalid"));

			Debug.Print("Reading gyro offset values...");
			var xgOffset = GetXGyroOffset(_imu, _imuConfig);
			var ygOffset = GetYGyroOffset(_imu, _imuConfig);
			var zgOffset = GetZGyroOffset(_imu, _imuConfig);
			Debug.Print("X gyro offset = " + xgOffset);
			Debug.Print("Y gyro offset = " + ygOffset);
			Debug.Print("Z gyro offset = " + zgOffset);

			Debug.Print("Enabling interrupt latch, clear on any read, AUX bypass enabled");
			WriteByte(_imu, _imuConfig, MPU6050_RA_INT_PIN_CFG, 0x32);

			Debug.Print("Setting magnetometer mode to power-down...");
			WriteByte(_imu, magConfig, 0x0A, 0x00);

			Debug.Print("Writing DMP code to MPU memory banks (" + DmpMemory9.Length + " bytes)");
			if (WriteProgMemoryBlock(_imu, _imuConfig, DmpMemory9))
			{
				Debug.Print("Success! DMP code written and verified.");
				Debug.Print("Configuring DMP and related settings...");
				Debug.Print("Writing DMP configuration to MPU memory banks (" + DmpConfig9.Length + " bytes in config def)");

				if (WriteProgDMPConfigurationSet(_imu, _imuConfig, DmpConfig9))
				{
					Debug.Print("Success! DMP configuration written and verified.");

					Debug.Print("Setting DMP and FIFO_OFLOW interrupts enabled...");
					WriteByte(_imu, _imuConfig, MPU6050_RA_INT_ENABLE, 0x12);

					Debug.Print("Setting sample rate to 200Hz...");
					WriteByte(_imu, _imuConfig, MPU6050_RA_SMPLRT_DIV, 4);// 1khz / (1 + 4) = 200 Hz

					Debug.Print("Setting clock source to Z Gyro...");
					WriteBits(_imu, _imuConfig, MPU6050_RA_PWR_MGMT_1, MPU6050_PWR1_CLKSEL_BIT, MPU6050_PWR1_CLKSEL_LENGTH, MPU6050_CLOCK_PLL_ZGYRO);

					Debug.Print("Setting DLPF bandwidth to 42Hz...");
					WriteBits(_imu, _imuConfig, MPU6050_RA_CONFIG, MPU6050_CFG_DLPF_CFG_BIT, MPU6050_CFG_DLPF_CFG_LENGTH, 3);

					Debug.Print("Setting external frame sync to TEMP_OUT_L[0]...");
					WriteBits(_imu, _imuConfig, MPU6050_RA_CONFIG, MPU6050_CFG_EXT_SYNC_SET_BIT, MPU6050_CFG_EXT_SYNC_SET_LENGTH, MPU6050_EXT_SYNC_TEMP_OUT_L);

					Debug.Print("Setting gyro sensitivity to +/- 2000 deg/sec...");
					WriteBits(_imu, _imuConfig, MPU6050_RA_GYRO_CONFIG, MPU6050_GCONFIG_FS_SEL_BIT, MPU6050_GCONFIG_FS_SEL_LENGTH, MPU6050_GYRO_FS_2000);

					Debug.Print("Setting DMP configuration bytes (function unknown)...");
					WriteByte(_imu, _imuConfig, MPU6050_RA_DMP_CFG_1, 0x03);
					WriteByte(_imu, _imuConfig, MPU6050_RA_DMP_CFG_2, 0x00);

					Debug.Print("Clearing OTP Bank flag...");
					WriteBits(_imu, _imuConfig, MPU6050_RA_XG_OFFS_TC, MPU6050_TC_OTP_BNK_VLD_BIT, 1, 0);

					Debug.Print("Setting X/Y/Z gyro offsets to previous values...");
					SetXGyroOffset(_imu, _imuConfig, xgOffset);
					SetYGyroOffset(_imu, _imuConfig, ygOffset);
					SetZGyroOffset(_imu, _imuConfig, zgOffset);

					WriteBytes(_imu, _imuConfig, MPU6050_RA_XG_OFFS_USRH, new byte[] { 0, 0 });
					WriteBytes(_imu, _imuConfig, MPU6050_RA_YG_OFFS_USRH, new byte[] { 0, 0 });
					WriteBytes(_imu, _imuConfig, MPU6050_RA_ZG_OFFS_USRH, new byte[] { 0, 0 });

					Debug.Print("Writing final memory update 1/19 (function unknown)...");
					var pos = 0;
					var dmpUpdate = new byte[16];
					for (var j = 0; j < 4 || j < dmpUpdate[2] + 3; j++, pos++) dmpUpdate[j] = DmpUpdates9[pos];

					var len = dmpUpdate[2];
					var tmp = new byte[len];
					Array.Copy(dmpUpdate, 3, tmp, 0, len);
					WriteMemoryBlock(_imu, _imuConfig, tmp, dmpUpdate[0], dmpUpdate[1]);

					Debug.Print("Writing final memory update 2/19 (function unknown)...");
					for (var j = 0; j < 4 || j < dmpUpdate[2] + 3; j++, pos++) dmpUpdate[j] = DmpUpdates9[pos];
					len = dmpUpdate[2];
					tmp = new byte[len];
					Array.Copy(dmpUpdate, 3, tmp, 0, len);
					WriteMemoryBlock(_imu, _imuConfig, tmp, dmpUpdate[0], dmpUpdate[1]);

					Debug.Print("Resetting FIFO...");
					WriteBits(_imu, _imuConfig, MPU6050_RA_USER_CTRL, MPU6050_USERCTRL_FIFO_RESET_BIT, 1, 1);

					Debug.Print("Reading FIFO count...");
					var fifoCount = GetFifoCount(_imu, _imuConfig);

					Debug.Print("Current FIFO count=" + fifoCount);

					Debug.Print("Disabling all standby flags...");
					WriteByte(_imu, _imuConfig, MPU6050_RA_PWR_MGMT_2, 0x00);

					Debug.Print("Setting accelerometer sensitivity to +/- 2g...");
					WriteByte(_imu, _imuConfig, MPU6050_RA_ACCEL_CONFIG, 0x00);

					Debug.Print("Setting motion detection threshold to 2...");
					WriteByte(_imu, _imuConfig, MPU6050_RA_MOT_THR, 2);

					Debug.Print("Setting zero-motion detection threshold to 156...");
					WriteByte(_imu, _imuConfig, MPU6050_RA_ZRMOT_THR, 156);

					Debug.Print("Setting motion detection duration to 80...");
					WriteByte(_imu, _imuConfig, MPU6050_RA_MOT_DUR, 80);

					Debug.Print("Setting zero-motion detection duration to 0...");
					WriteByte(_imu, _imuConfig, MPU6050_RA_ZRMOT_DUR, 0);

					Debug.Print("Setting AK8975 to single measurement mode...");
					//mag -> setMode(1);
					WriteByte(_imu, magConfig, 0x0A, 0x01);

					// setup AK8975 (0x0E) as Slave 0 in read mode
					Debug.Print("Setting up AK8975 read slave 0...");
					WriteByte(_imu, _imuConfig, MPU6050_RA_I2C_SLV0_ADDR, 0x8E);
					WriteByte(_imu, _imuConfig, MPU6050_RA_I2C_SLV0_REG, 0x01);
					WriteByte(_imu, _imuConfig, MPU6050_RA_I2C_SLV0_CTRL, 0xDA);

					// setup AK8975 (0x0E) as Slave 2 in write mode
					Debug.Print("Setting up AK8975 write slave 2...");
					WriteByte(_imu, _imuConfig, MPU6050_RA_I2C_SLV2_ADDR, 0x0E);
					WriteByte(_imu, _imuConfig, MPU6050_RA_I2C_SLV2_REG, 0x0A);
					WriteByte(_imu, _imuConfig, MPU6050_RA_I2C_SLV2_CTRL, 0x81);
					WriteByte(_imu, _imuConfig, MPU6050_RA_I2C_SLV2_DO, 0x01);

					// setup I2C timing/delay control
					Debug.Print("Setting up slave access delay...");
					WriteByte(_imu, _imuConfig, MPU6050_RA_I2C_SLV4_CTRL, 0x18);
					WriteByte(_imu, _imuConfig, MPU6050_RA_I2C_MST_DELAY_CTRL, 0x05);

					// enable interrupts
					Debug.Print("Enabling default interrupt behavior/no bypass...");
					WriteByte(_imu, _imuConfig, MPU6050_RA_INT_PIN_CFG, 0x00);

					// enable I2C master mode and reset DMP/FIFO
					Debug.Print("Enabling I2C master mode...");
					WriteByte(_imu, _imuConfig, MPU6050_RA_USER_CTRL, 0x20);
					Debug.Print("Resetting FIFO...");
					WriteByte(_imu, _imuConfig, MPU6050_RA_USER_CTRL, 0x24);
					Debug.Print("Rewriting I2C master mode enabled because...I don't know");
					WriteByte(_imu, _imuConfig, MPU6050_RA_USER_CTRL, 0x20);
					Debug.Print("Enabling and resetting DMP/FIFO...");
					WriteByte(_imu, _imuConfig, MPU6050_RA_USER_CTRL, 0xE8);

					for (var i = 5; i <= 17; i++)
					{
						if (i != 12)
						{
							Debug.Print("Writing final memory update " + i + "/19 (function unknown)...");
							for (var j = 0; j < 4 || j < dmpUpdate[2] + 3; j++, pos++) dmpUpdate[j] = DmpUpdates9[pos];
							len = dmpUpdate[2];
							tmp = new byte[len];
							Array.Copy(dmpUpdate, 3, tmp, 0, len);
							WriteMemoryBlock(_imu, _imuConfig, tmp, dmpUpdate[0], dmpUpdate[1]);
						}
					}

					Debug.Print("Waiting for FIRO count >= 46...");
					while ((fifoCount = GetFifoCount(_imu, _imuConfig)) < 46)
					{
					}
					Debug.Print("Reading FIFO...");
					GetFifoBytes(_imu, _imuConfig, System.Math.Min(fifoCount, 128)); // safeguard only 128 bytes
					Debug.Print("Reading interrupt status...");
					GetIntStatus(_imu, _imuConfig);

					Debug.Print("Disabling DMP (you turn it on later)...");
					WriteBits(_imu, _imuConfig, MPU6050_RA_USER_CTRL, MPU6050_USERCTRL_DMP_EN_BIT, 1, 0);

					Debug.Print("Resetting FIFO and clearing INT status one last time...");
					WriteBits(_imu, _imuConfig, MPU6050_RA_USER_CTRL, MPU6050_USERCTRL_FIFO_RESET_BIT, 1, 1);
				}
			}

			Debug.Print("Enabling DMP");
			WriteBits(_imu, _imuConfig, MPU6050_RA_USER_CTRL, MPU6050_USERCTRL_DMP_EN_BIT, 1, 1);

			var inter = new InterruptPort(Pin.PA26, false, Port.ResistorMode.PullUp, Port.InterruptMode.InterruptEdgeHigh);
			inter.OnInterrupt += inter_OnInterrupt;

			/*var start = DateTime.Now;
			const int interval = 50;
			var a = 0;
			while (true)
			{
				int fifoCount;
				while ((fifoCount = GetFifoCount(imu, imuConfig)) < 46)
				{
				}

				var fifo = GetFifoBytes(imu, imuConfig, System.Math.Min(fifoCount, 128)); // safeguard only 128 bytes
				var acc = GetAccel(fifo);
				var q = GetQuaternion(fifo);
				var euler = GetEuler(q);
				//Debug.Print(acc[0] + "/" + acc[1] + "/" + acc[2]);
				//Debug.Print(euler[0] + "/" + euler[1] + "/" + euler[2]);
				//Debug.Print(q.W + "/" + q.X + "/" + q.Y + "/" + q.Z);

				if (a == 0)
				{
					_lastAngle = euler[2];
				}

				var angle = euler[2];
				//if (System.Math.Abs(angle - _lastAngle) <= 4)
				{
					var angleFilter = (angle + _lastAngle) / 2;
					var output = pid.Compute(angleFilter) + .3;
					_lastAngle = angle;
					Debug.Print(angleFilter + "\t" + output);
					pwm.Duration = (uint)((1 + 0.7) * 1000);
				}
				//var duration = DateTime.Now - start;
				//Debug.Print((duration.Ticks / 10000.0 / a).ToString());
				//}
				a++;
			}*/

			Thread.Sleep(int.MaxValue);

			/*DisableSleepMode(imu, imuConfig);
			InitMag(imu, imuConfig, magConfig);

			Debug.Print("Sensor initialized");

			const int interval = 50;
			var pos = 0;
			while (true)
			{
				var accData = ReadBytes(imu, imuConfig, 0x3B, 14);
				var magData = ReadBytes(imu, magConfig, MPU9150_RA_MAG_XOUT_L, 6);

				var acc = new int[6];
				for (var j = 0; j < 6; j++)
				{
					acc[j] = accData[j * 2] << 8 | accData[j * 2 + 1];
				}

				var mag = new int[3];
				for (var j = 0; j < 3; j++)
				{
					mag[j] = magData[j * 2] << 8 | magData[j * 2 + 1];
				}

				if (pos % interval == 0)
				{
					Debug.Print("Acc:" + acc[0] + "/" + acc[1] + "/" + acc[2]);
					Debug.Print("Gyro:" + acc[3] + "/" + acc[4] + "/" + acc[5]);
					Debug.Print("Mag:" + mag[0] + "/" + mag[1] + "/" + mag[2]);
				}
				pos++;
			}*/
		}

		static void inter_OnInterrupt(uint data1, uint data2, DateTime time)
		{
			var fifoCount = GetFifoCount(_imu, _imuConfig);
			if (fifoCount >= 48)
			{
				var fifo = GetFifoBytes(_imu, _imuConfig, System.Math.Min(fifoCount, 128)); // safeguard only 128 bytes

				if (fifoCount % 48 != 0)
					return;

				var acc = GetAccel(fifo);
				var gyro = GetGyro(fifo);
				var q = GetQuaternion(fifo);
				var euler = GetEuler(q);
				var grav = GetGravity(q);
				var pitch = GetYawPitchRoll(q, grav);
				//Debug.Print(acc[0] + "\t" + acc[1] + "\t" + acc[2]);
				//Debug.Print(gyro[0] + "\t" + gyro[1] + "\t" + gyro[2]);
				//Debug.Print(euler[0] + "\t" + euler[1] + "\t" + euler[2]);
				//Debug.Print(pitch[0] + "\t" + pitch[1] + "\t" + pitch[2]);
				//Debug.Print(q.W + "\t" + q.X + "\t" + q.Y + "\t" + q.Z);
				//Debug.Print(_pwmInput[3].ToString());

				var angle = pitch[2];
				angle = _lowPassFilter.Input(angle);
				angle += _pwmInput[1] * 20;

				/*_lowPassFilterGyro.Update((float) gyro[0]);
				var gyroFilter = _lowPassFilterGyro.Value;*/

				_pid.Kd = .001 + (_pwmInput[5]) * .001;
				//_pid.Kp = -.002 - (_pwmInput[5]) * .002;

				var output = _pid.Compute(angle, gyro[0]);
				//output = 0;
				var push = (_pwmInput[2] + 1) / 2;
				push = (float)(.4 + ((_pwmInput[2] + 1) / 2) * .3);
				//push = 0;
				_pwm1.Duration = (uint)((1 + push - output) * PwmPeriode / 20);
				_pwm2.Duration = (uint)((1 + push + output) * PwmPeriode / 20);
				Debug.Print(angle + "\t" + gyro[0] + "\t" + fifoCount + "\t" + output + "\tKi=" + _pid.Ki + "\tKp=" + _pid.Kp + "\tKd=" + _pid.Kd + "\tp=" + push);

				/*const ushort on = 1;
				var off = (ushort)((double)4095 / 20 * (1 + .5 - output) + 1);
				WriteBytes(_imu, _motorConfig, 0x6, new[] { (byte)on, (byte)(on >> 8), (byte)off, (byte)(off >> 8) });
				off = (ushort)((double)4095 / 20 * (1 + .5 + output) + 1);
				WriteBytes(_imu, _motorConfig, 0x6 + 4, new[] { (byte)on, (byte)(on >> 8), (byte)off, (byte)(off >> 8) });*/

				_pos++;
			}
		}

		static void uart_DataReceived(object sender, SerialDataReceivedEventArgs e)
		{

		}

		private static double[] GetEuler(Quaternion q)
		{
			var data = new double[3];
			data[0] = System.Math.Atan2(2 * q.X * q.Y - 2 * q.W * q.Z, 2 * q.W * q.W + 2 * q.X * q.X - 1) / System.Math.PI * 180;   // psi
			data[1] = -System.Math.Asin(-2 * (q.X * q.Z - q.W * q.Y)) / System.Math.PI * 180;                                       // theta
			data[2] = System.Math.Atan2(2 * q.Y * q.Z - 2 * q.W * q.X, 2 * q.W * q.W + 2 * q.Z * q.Z - 1) / System.Math.PI * 180;   // phi
			return data;
		}

		private static double[] GetYawPitchRoll(Quaternion q, double[] g)
		{
			var data = new double[3];
			data[0] = System.Math.Atan2(2 * q.X * q.Y - 2 * q.W * q.Z, 2 * q.W * q.W + 2 * q.X * q.X - 1) / System.Math.PI * 180;   // psi
			var div = System.Math.Sqrt(g[0] * g[0] + g[2] * g[2]);
			if (div != 0)
			{
				data[1] = System.Math.Atan(g[0] / div) / System.Math.PI * 180; // theta
				data[2] = System.Math.Atan(g[1] / div) / System.Math.PI * 180; // phi
			}
			return data;
		}

		private static double[] GetGravity(Quaternion q)
		{
			var data = new double[3];
			data[0] = 2 * (q.X * q.Z - q.W * q.Y); // x
			data[1] = 2 * (q.W * q.X + q.Y * q.Z); // y
			data[2] = q.W * q.W - q.X * q.X - q.Y * q.Y + q.Z * q.Z; // z
			return data;
		}

		private static Quaternion GetQuaternion(byte[] packet)
		{
			var data = new short[4];
			data[0] = (short)((packet[0] << 8) + (packet[1]));
			data[1] = (short)((packet[4] << 8) + (packet[5]));
			data[2] = (short)((packet[8] << 8) + (packet[9]));
			data[3] = (short)((packet[12] << 8) + (packet[13]));

			return new Quaternion
			{
				W = data[0] / (double)ushort.MaxValue,
				X = data[1] / (double)ushort.MaxValue,
				Y = data[2] / (double)ushort.MaxValue,
				Z = data[3] / (double)ushort.MaxValue
			};
		}

		private static short[] GetAccel(byte[] packet)
		{
			var data = new short[3];
			data[0] = (short)((packet[34] << 8) + packet[35]);
			data[1] = (short)((packet[38] << 8) + packet[39]);
			data[2] = (short)((packet[42] << 8) + packet[43]);
			return data;
		}

		private static short[] GetGyro(byte[] packet)
		{
			var data = new short[3];
			data[0] = (short)((packet[16] << 8) + (packet[17]));
			data[1] = (short)((packet[20] << 8) + (packet[21]));
			data[2] = (short)((packet[24] << 8) + (packet[25]));
			return data;
		}

		private static short[] GetMag(byte[] packet)
		{
			var data = new short[3];
			data[0] = (short)((packet[28] << 8) + packet[29]);
			data[1] = (short)((packet[30] << 8) + packet[31]);
			data[2] = (short)((packet[32] << 8) + packet[33]);
			return data;
		}

		private static void SetMemoryBank(I2CDevice dev, I2CDevice.Configuration config, int bank, bool prefetchEnabled = false, bool userBank = false)
		{
			bank &= 0x1F;
			if (userBank) bank |= 0x20;
			if (prefetchEnabled) bank |= 0x40;


			var transactions = new I2CDevice.I2CTransaction[1];
			transactions[0] = I2CDevice.CreateWriteTransaction(new[] { MPU6050_RA_BANK_SEL, (byte)bank });

			dev.Config = config;
			if (dev.Execute(transactions, I2CTimeout) == 0)
			{
				Debug.Print("Failed to perform I2C transaction");
			}
		}
		private static void SetMemoryStartAddress(I2CDevice dev, I2CDevice.Configuration config, byte address)
		{
			var transactions = new I2CDevice.I2CTransaction[1];
			transactions[0] = I2CDevice.CreateWriteTransaction(new[] { MPU6050_RA_MEM_START_ADDR, address });

			dev.Config = config;
			if (dev.Execute(transactions, I2CTimeout) == 0)
			{
				Debug.Print("Failed to perform I2C transaction");
			}
		}

		private static bool GetOtpBankValid(I2CDevice dev, I2CDevice.Configuration config)
		{
			var transactions = new I2CDevice.I2CTransaction[2];
			transactions[0] = I2CDevice.CreateWriteTransaction(new[] { MPU6050_RA_XG_OFFS_TC });
			var buffer = new byte[1];
			transactions[1] = I2CDevice.CreateReadTransaction(buffer);

			lock (dev)
			{
				dev.Config = config;
				if (dev.Execute(transactions, I2CTimeout) == 0)
				{
					Debug.Print("Failed to perform I2C transaction");
					return false;
				}
			}
			return buffer[0] > 0;
		}

		private static int GetFifoCount(I2CDevice dev, I2CDevice.Configuration config)
		{
			var data = ReadBytes(dev, config, MPU6050_RA_FIFO_COUNTH, 2);
			return ((data[0]) << 8) | data[1];
		}

		private static byte[] GetFifoBytes(I2CDevice dev, I2CDevice.Configuration config, int length)
		{
			return ReadBytes(dev, config, MPU6050_RA_FIFO_R_W, length);
		}

		private static byte GetIntStatus(I2CDevice dev, I2CDevice.Configuration config)
		{
			return ReadBytes(dev, config, MPU6050_RA_INT_STATUS, 1)[0];
		}

		private static void WriteByte(I2CDevice dev, I2CDevice.Configuration config, byte block, byte data)
		{
			var transactions = new I2CDevice.I2CTransaction[1];
			transactions[0] = I2CDevice.CreateWriteTransaction(new[] { block, data });

			lock (dev)
			{
				dev.Config = config;
				if (dev.Execute(transactions, I2CTimeout) == 0)
				{
					throw new Exception("Failed to perform I2C transaction");
				}
			}
		}

		private static void WriteBytes(I2CDevice dev, I2CDevice.Configuration config, byte block, byte[] data)
		{
			var transactions = new I2CDevice.I2CTransaction[1];
			var buffer = new byte[data.Length + 1];
			buffer[0] = block;
			Array.Copy(data, 0, buffer, 1, data.Length);
			transactions[0] = I2CDevice.CreateWriteTransaction(buffer);
			lock (dev)
			{
				dev.Config = config;
				if (dev.Execute(transactions, I2CTimeout) == 0)
				{
					throw new Exception("Failed to perform I2C transaction");
				}
			}
		}

		private static byte[] ReadBytes(I2CDevice dev, I2CDevice.Configuration config, byte block, int length)
		{
			var transactions = new I2CDevice.I2CTransaction[2];
			transactions[0] = I2CDevice.CreateWriteTransaction(new[] { block });
			var buffer = new byte[length];
			transactions[1] = I2CDevice.CreateReadTransaction(buffer);

			lock (dev)
			{
				dev.Config = config;
				if (dev.Execute(transactions, I2CTimeout) == 0)
				{
					//throw new Exception("Failed to perform I2C transaction");
				}
			}
			return buffer;
		}

		private static void WriteBits(I2CDevice dev, I2CDevice.Configuration config, byte block, byte bitStart, byte length, byte data)
		{
			var transactions = new I2CDevice.I2CTransaction[2];
			transactions[0] = I2CDevice.CreateWriteTransaction(new[] { block });
			var buffer = new byte[1];
			transactions[1] = I2CDevice.CreateReadTransaction(buffer);

			lock (dev)
			{
				dev.Config = config;
				if (dev.Execute(transactions, I2CTimeout) == 0)
				{
					throw new Exception("Failed to perform I2C transaction");
				}

				var mask = ((1 << length) - 1) << (bitStart - length + 1);
				data <<= (bitStart - length + 1); // shift data into correct position
				data = (byte)(data & mask); // zero all non-important bits in data
				buffer[0] = (byte)(buffer[0] & ~(mask)); // zero all important bits in existing byte
				buffer[0] |= data; // combine data with existing byte

				WriteByte(dev, config, block, buffer[0]);
			}
		}

		private static bool WriteProgMemoryBlock(I2CDevice dev, I2CDevice.Configuration config, byte[] data, byte bank = 0, byte address = 0, bool verify = true)
		{
			return WriteMemoryBlock(dev, config, data, bank, address, verify);
		}

		private static bool WriteProgDMPConfigurationSet(I2CDevice dev, I2CDevice.Configuration config, byte[] data)
		{
			for (int i = 0; i < data.Length; )
			{
				var bank = data[i++];
				var offset = data[i++];
				var length = data[i++];

				if (length > 0)
				{
					var buffer = new byte[length];
					Array.Copy(data, i, buffer, 0, length);
					WriteMemoryBlock(dev, config, buffer, bank, offset);
					i += length;
				}
				else
				{
					var special = data[i++];

					if (special == 0x01)
					{
						// enable DMP-related interrupts

						//setIntZeroMotionEnabled(true);
						//setIntFIFOBufferOverflowEnabled(true);
						//setIntDMPEnabled(true);

						WriteByte(dev, config, MPU6050_RA_INT_ENABLE, 0x32);
					}
					else
					{
						// unknown special command
						return false;
					}
				}
			}
			return true;
		}

		private static bool WriteMemoryBlock(I2CDevice dev, I2CDevice.Configuration config, byte[] data, byte bank = 0, byte address = 0, bool verify = true)
		{
			SetMemoryBank(dev, config, bank);
			SetMemoryStartAddress(dev, config, address);

			var verifyBuffer = new byte[MPU6050_DMP_MEMORY_CHUNK_SIZE];

			for (var i = 0; i < data.Length; )
			{
				int chunkSize = MPU6050_DMP_MEMORY_CHUNK_SIZE;
				if (i + chunkSize > data.Length) chunkSize = data.Length - i;
				if (chunkSize > 256 - address) chunkSize = 256 - address;

				var buffer = new byte[chunkSize + 1];
				buffer[0] = MPU6050_RA_MEM_R_W;
				Array.Copy(data, i, buffer, 1, chunkSize);

				var transactions = new I2CDevice.I2CTransaction[1];
				transactions[0] = I2CDevice.CreateWriteTransaction(buffer);

				dev.Config = config;
				if (dev.Execute(transactions, 1000) == 0)
				{
					throw new Exception("Failed to perform I2C transaction");
				}

				i += chunkSize;
				address = (byte)(address + chunkSize);

				if (i < data.Length)
				{
					if (address == 0) bank++;
					SetMemoryBank(dev, config, bank);
					SetMemoryStartAddress(dev, config, address);
				}
			}

			return true;
		}

		private static byte GetXGyroOffset(I2CDevice dev, I2CDevice.Configuration config)
		{
			return ReadBytes(dev, config, MPU6050_RA_XG_OFFS_TC, 1)[0];
		}

		private static void SetXGyroOffset(I2CDevice dev, I2CDevice.Configuration config, byte value)
		{
			WriteByte(dev, config, MPU6050_RA_XG_OFFS_TC, value);
		}

		private static byte GetYGyroOffset(I2CDevice dev, I2CDevice.Configuration config)
		{
			return ReadBytes(dev, config, MPU6050_RA_YG_OFFS_TC, 1)[0];
		}

		private static void SetYGyroOffset(I2CDevice dev, I2CDevice.Configuration config, byte value)
		{
			WriteByte(dev, config, MPU6050_RA_YG_OFFS_TC, value);
		}

		private static byte GetZGyroOffset(I2CDevice dev, I2CDevice.Configuration config)
		{
			return ReadBytes(dev, config, MPU6050_RA_ZG_OFFS_TC, 1)[0];
		}

		private static void SetZGyroOffset(I2CDevice dev, I2CDevice.Configuration config, byte value)
		{
			WriteByte(dev, config, MPU6050_RA_ZG_OFFS_TC, value);
		}


		public static void DisableSleepMode(I2CDevice dev, I2CDevice.Configuration config)
		{
			WriteBits(dev, config, MPU6050_RA_PWR_MGMT_1, MPU6050_PWR1_SLEEP_BIT, 1, 0);
		}

		public static void InitMag(I2CDevice dev, I2CDevice.Configuration imuConfig, I2CDevice.Configuration magConfig)
		{
			WriteByte(dev, imuConfig, MPU6050_RA_INT_PIN_CFG, 0x02);
			WriteByte(dev, magConfig, 0x0A, 0x01);
		}

		private class Quaternion
		{
			public double W;
			public double X;
			public double Y;
			public double Z;
		}
	}
}
